# coding: utf-8'''Receive request from queue ,then reverse,send result to queue;'''import timeimport osimport jsonfrom threading import Threadimport signal# rabbitmqimport RabbitMQ# sqlalchemyfrom collections import defaultdictfrom ORM import *config = RabbitMQ.getConfig()try:    channel = RabbitMQ.getChannel()    reverseResultQueue = config["reverseResultQueue"]    reverseRequestQueue = config["reverseRequestQueue"]    channel.queue_declare(queue = reverseResultQueue)    channel.queue_declare(queue = reverseRequestQueue)except:    print("error accour in connection to rabbitMQ")Session = sessionmaker(bind = engine)'''class ConnectionLink'''query = ("select my_ip,next_ip,next_port,prev_circ_id,next_circ_id,direction,stream_id,is_origin from net "         "where time between %s and %s ")config = {}with open("config.json") as f:    t = f.read()    config = json.loads(t)def exiter(_1, _2):    os._exit(0)def readFromDB(start_time = None, end_time = time.time()):    '''    use my_ip as key    use prev_circ as second key (accelerate search whether prev_circ is there)    start_time:long(time stamp)    end_time:long    rtype dict(),dict() --{"my_ip":{"prev_circ_id":link}},{...}    '''    if (start_time is None):        # default -30 minutes        start_time = end_time - 30 * 60    end_time = end_time + 1    relay = defaultdict(dict)    origin = defaultdict(dict)    session = Session()    for instance in session.query(Link).filter(            sqlalchemy.and_(Link.datetime >= start_time, Link.datetime <= end_time)).order_by(Link.id):        # for instance in session.query(Link).order_by(Link.id):        if (instance.is_origin):            origin[instance.my_ip][instance.prev_circ_id] = instance        else:            relay[instance.my_ip][instance.prev_circ_id] = instance    return origin, relayorigins, relays = defaultdict(dict), defaultdict(dict)  # global var#     return Nonedef searchNext(p, relays):    # todo using direction to estimate whether this relay is right    # p:type link  --the previous one    # relay:type dict {"my_ip":{"prev_circ_id":link}} --the relay dict    # return list(link)  --the list from p {type:link} to end looks like [p1,p2,p3]    if (p.next_ip in relays):        nls = relays[p.next_ip]        #         print(nls)        if (p.next_circ_id in nls):  # prev_relay.next_circ_id equals to the next one's prev_circ_id            t = searchNext(nls[p.next_circ_id], relays)            if (t is not None):                t.insert(0, p)                return t            else:                # The last one is nls[p.next_circ_id]                return [p, nls[p.next_circ_id]]    return Nonedef linkAll(start_time = None, end_time = time.time()):    '''    link all relays order by url_id    :return:reversedLinks: dict("url_id":list(list(link))) {id:[[p1,p2,p3],[p1,p3,p4,p5]]}    '''    reversedLinks = defaultdict(list)    origins, relays = readFromDB(start_time, end_time)    #     print(origins,relays)    for oStr in origins:  # though all the origin.Origins types {"my_ip":{"prev_circ_id":link}}        o = origins[oStr]  # O types {"prev_circ_id":link}        for prev_circ_id in o:  # all the next ip            p = o[prev_circ_id]  # p types link            t = searchNext(p, relays)            if (t != None and t.__len__() == 7):                reversedLinks[p.url_id].append(t)    return reversedLinksdef saveLinkedRelays(reversedLinks):    '''    :reversedLinks:dict("url_id":list(list(link))) {id:[[p1,p2,p3],[p1,p3,p4,p5]]}    :return: urls,connectionLinks    save connectionlinks into database    '''    session = Session()    urls = []    connectionLinks = []    for u in reversedLinks:        url = session.query(Url).filter_by(url_id = u).first()        print(url)        # urls.append()        print(reversedLinks[u][0][-1].next_ip)        print(type(url))        url.server_ip = reversedLinks[u][0][-1].next_ip        urls.append(url)        for linkList in reversedLinks[u]:            c = session.query(ConnectionLink).filter_by(request_id = linkList[0].request_id).first()            if c is None:                c = ConnectionLink(request_id = linkList[0].request_id, url_id = linkList[0].url_id,                    datetime = linkList[0].datetime                    , client = linkList[0].my_ip, server = linkList[-1].next_ip,                    link1 = linkList[0].id, link2 = linkList[1].id, link3 = linkList[2].id, linkmid = linkList[3].id,                    link4 = linkList[4].id, link5 = linkList[5].id, link6 = linkList[6].id)            else:                help(c)                c.url_id = linkList[0].url_id                c.datetime = linkList[0].datetime                c.client = linkList[0].my_ip                c.server = linkList[-1].next_ip                c.link1 = linkList[0].id                c.link2 = linkList[1].id                c.link3 = linkList[2].id                c.linkmid = linkList[3].id                c.link4 = linkList[4].id                c.link5 = linkList[5].id                c.link6 = linkList[6].id            connectionLinks.append(c)    session.add_all(urls)    session.add_all(connectionLinks)    session.commit()    return urls, connectionLinksdef test():    session = Session()    session.add(Url(url_id = 2, url = "www.baidu.com"))    list = []    list.append(Link(request_id = 1, url_id = 2, datetime = time.time(),        prev_circ_id = 1, next_circ_id = 2, my_ip = "10.0.0.1", next_ip = "10.0.0.2",        next_port = 1900, direction = 1, stream_id = 0, is_origin = 1))    list.append(Link(datetime = time.time(),        prev_circ_id = 2, next_circ_id = 3, my_ip = "10.0.0.2", next_ip = "10.0.0.3",        next_port = 1900, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 2, next_circ_id = 3, my_ip = "10.0.0.2", next_ip = "10.0.0.3",        next_port = 1900, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 3, next_circ_id = 4, my_ip = "10.0.0.3", next_ip = "10.0.0.4",        next_port = 900, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 4, next_circ_id = 5, my_ip = "10.0.0.4", next_ip = "10.0.0.5",        next_port = 190, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 5, next_circ_id = 6, my_ip = "10.0.0.5", next_ip = "10.0.0.3",        next_port = 1900, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 6, next_circ_id = 7, my_ip = "10.0.0.3", next_ip = "10.0.0.4",        next_port = 900, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 7, next_circ_id = 8, my_ip = "10.0.0.4", next_ip = "10.0.0.5",        next_port = 190, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 8, next_circ_id = 8, my_ip = "10.0.0.4", next_ip = "10.0.0.5",        next_port = 190, direction = 1, stream_id = 0, is_origin = 0))    list.append(Link(datetime = time.time(),        prev_circ_id = 1, next_circ_id = 10, my_ip = "10.0.0.4", next_ip = "10.0.0.5",        next_port = 190, direction = 1, stream_id = 0, is_origin = 0))    session.add_all(list)    session.commit()    reversedLists = linkAll()    return saveLinkedRelays(reversedLinks = reversedLists)def testSQL():    session = Session()    url = Url(url_id = 4, server_ip = "123", url = "sdf")    session.add(url)    session.commit()    # session=Session()    # url=session.query(Url).filter_by(url_id=2).first()    # url.values(sever_ip="1231231")    #    # print(url)    # session.add(url)    # session.commit()def waitForReverseRequest(ch, method, properties, body):    task = json.loads(body)    # url = Url(url)    # todo fix this task    channel.basic_ack(delivery_tag = method.delivery_tag)def reverseThread():    while (True):        print(".")        reversedLists = linkAll()        try:            urls, connectionLinks = saveLinkedRelays(reversedLinks = reversedLists)            # send Links            channel.basic_publish(exchange = '', routing_key = reverseResultQueue,                body = json.dumps({"urls": [c.toJson() for c in urls], "links": [c.toJson() for c in connectionLinks]}))        except:            print("error accour in saveLink or publish to queue")        time.sleep(1)if __name__ == "__main__":    # test()    # testSQL()    signal.signal(signal.SIGINT, exiter)    t = Thread(target = reverseThread)    t.start()    channel.basic_qos(prefetch_count = 1)    channel.basic_consume(waitForReverseRequest, reverseRequestQueue, no_ack = False)    channel.start_consuming()